// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'bookmarked_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$BookmarkedState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loaded,
    required TResult Function() loading,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loaded,
    TResult? Function()? loading,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loaded,
    TResult Function()? loading,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadedBookmarkedState value) loaded,
    required TResult Function(LoadingBookmarkedState value) loading,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadedBookmarkedState value)? loaded,
    TResult? Function(LoadingBookmarkedState value)? loading,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadedBookmarkedState value)? loaded,
    TResult Function(LoadingBookmarkedState value)? loading,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BookmarkedStateCopyWith<$Res> {
  factory $BookmarkedStateCopyWith(
          BookmarkedState value, $Res Function(BookmarkedState) then) =
      _$BookmarkedStateCopyWithImpl<$Res, BookmarkedState>;
}

/// @nodoc
class _$BookmarkedStateCopyWithImpl<$Res, $Val extends BookmarkedState>
    implements $BookmarkedStateCopyWith<$Res> {
  _$BookmarkedStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BookmarkedState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$LoadedBookmarkedStateImplCopyWith<$Res> {
  factory _$$LoadedBookmarkedStateImplCopyWith(
          _$LoadedBookmarkedStateImpl value,
          $Res Function(_$LoadedBookmarkedStateImpl) then) =
      __$$LoadedBookmarkedStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadedBookmarkedStateImplCopyWithImpl<$Res>
    extends _$BookmarkedStateCopyWithImpl<$Res, _$LoadedBookmarkedStateImpl>
    implements _$$LoadedBookmarkedStateImplCopyWith<$Res> {
  __$$LoadedBookmarkedStateImplCopyWithImpl(_$LoadedBookmarkedStateImpl _value,
      $Res Function(_$LoadedBookmarkedStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of BookmarkedState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadedBookmarkedStateImpl implements LoadedBookmarkedState {
  const _$LoadedBookmarkedStateImpl();

  @override
  String toString() {
    return 'BookmarkedState.loaded()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedBookmarkedStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loaded,
    required TResult Function() loading,
  }) {
    return loaded();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loaded,
    TResult? Function()? loading,
  }) {
    return loaded?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loaded,
    TResult Function()? loading,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadedBookmarkedState value) loaded,
    required TResult Function(LoadingBookmarkedState value) loading,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadedBookmarkedState value)? loaded,
    TResult? Function(LoadingBookmarkedState value)? loading,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadedBookmarkedState value)? loaded,
    TResult Function(LoadingBookmarkedState value)? loading,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class LoadedBookmarkedState implements BookmarkedState {
  const factory LoadedBookmarkedState() = _$LoadedBookmarkedStateImpl;
}

/// @nodoc
abstract class _$$LoadingBookmarkedStateImplCopyWith<$Res> {
  factory _$$LoadingBookmarkedStateImplCopyWith(
          _$LoadingBookmarkedStateImpl value,
          $Res Function(_$LoadingBookmarkedStateImpl) then) =
      __$$LoadingBookmarkedStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingBookmarkedStateImplCopyWithImpl<$Res>
    extends _$BookmarkedStateCopyWithImpl<$Res, _$LoadingBookmarkedStateImpl>
    implements _$$LoadingBookmarkedStateImplCopyWith<$Res> {
  __$$LoadingBookmarkedStateImplCopyWithImpl(
      _$LoadingBookmarkedStateImpl _value,
      $Res Function(_$LoadingBookmarkedStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of BookmarkedState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadingBookmarkedStateImpl implements LoadingBookmarkedState {
  const _$LoadingBookmarkedStateImpl();

  @override
  String toString() {
    return 'BookmarkedState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadingBookmarkedStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loaded,
    required TResult Function() loading,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loaded,
    TResult? Function()? loading,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loaded,
    TResult Function()? loading,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadedBookmarkedState value) loaded,
    required TResult Function(LoadingBookmarkedState value) loading,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadedBookmarkedState value)? loaded,
    TResult? Function(LoadingBookmarkedState value)? loading,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadedBookmarkedState value)? loaded,
    TResult Function(LoadingBookmarkedState value)? loading,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class LoadingBookmarkedState implements BookmarkedState {
  const factory LoadingBookmarkedState() = _$LoadingBookmarkedStateImpl;
}

/// @nodoc
mixin _$ResolveBookmarkedState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loaded,
    required TResult Function() loading,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loaded,
    TResult? Function()? loading,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loaded,
    TResult Function()? loading,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadedResolveBookmarkedState value) loaded,
    required TResult Function(LoadingResolveBookmarkedState value) loading,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadedResolveBookmarkedState value)? loaded,
    TResult? Function(LoadingResolveBookmarkedState value)? loading,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadedResolveBookmarkedState value)? loaded,
    TResult Function(LoadingResolveBookmarkedState value)? loading,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResolveBookmarkedStateCopyWith<$Res> {
  factory $ResolveBookmarkedStateCopyWith(ResolveBookmarkedState value,
          $Res Function(ResolveBookmarkedState) then) =
      _$ResolveBookmarkedStateCopyWithImpl<$Res, ResolveBookmarkedState>;
}

/// @nodoc
class _$ResolveBookmarkedStateCopyWithImpl<$Res,
        $Val extends ResolveBookmarkedState>
    implements $ResolveBookmarkedStateCopyWith<$Res> {
  _$ResolveBookmarkedStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ResolveBookmarkedState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$LoadedResolveBookmarkedStateImplCopyWith<$Res> {
  factory _$$LoadedResolveBookmarkedStateImplCopyWith(
          _$LoadedResolveBookmarkedStateImpl value,
          $Res Function(_$LoadedResolveBookmarkedStateImpl) then) =
      __$$LoadedResolveBookmarkedStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadedResolveBookmarkedStateImplCopyWithImpl<$Res>
    extends _$ResolveBookmarkedStateCopyWithImpl<$Res,
        _$LoadedResolveBookmarkedStateImpl>
    implements _$$LoadedResolveBookmarkedStateImplCopyWith<$Res> {
  __$$LoadedResolveBookmarkedStateImplCopyWithImpl(
      _$LoadedResolveBookmarkedStateImpl _value,
      $Res Function(_$LoadedResolveBookmarkedStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of ResolveBookmarkedState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadedResolveBookmarkedStateImpl
    implements LoadedResolveBookmarkedState {
  const _$LoadedResolveBookmarkedStateImpl();

  @override
  String toString() {
    return 'ResolveBookmarkedState.loaded()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedResolveBookmarkedStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loaded,
    required TResult Function() loading,
  }) {
    return loaded();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loaded,
    TResult? Function()? loading,
  }) {
    return loaded?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loaded,
    TResult Function()? loading,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadedResolveBookmarkedState value) loaded,
    required TResult Function(LoadingResolveBookmarkedState value) loading,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadedResolveBookmarkedState value)? loaded,
    TResult? Function(LoadingResolveBookmarkedState value)? loading,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadedResolveBookmarkedState value)? loaded,
    TResult Function(LoadingResolveBookmarkedState value)? loading,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class LoadedResolveBookmarkedState implements ResolveBookmarkedState {
  const factory LoadedResolveBookmarkedState() =
      _$LoadedResolveBookmarkedStateImpl;
}

/// @nodoc
abstract class _$$LoadingResolveBookmarkedStateImplCopyWith<$Res> {
  factory _$$LoadingResolveBookmarkedStateImplCopyWith(
          _$LoadingResolveBookmarkedStateImpl value,
          $Res Function(_$LoadingResolveBookmarkedStateImpl) then) =
      __$$LoadingResolveBookmarkedStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingResolveBookmarkedStateImplCopyWithImpl<$Res>
    extends _$ResolveBookmarkedStateCopyWithImpl<$Res,
        _$LoadingResolveBookmarkedStateImpl>
    implements _$$LoadingResolveBookmarkedStateImplCopyWith<$Res> {
  __$$LoadingResolveBookmarkedStateImplCopyWithImpl(
      _$LoadingResolveBookmarkedStateImpl _value,
      $Res Function(_$LoadingResolveBookmarkedStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of ResolveBookmarkedState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadingResolveBookmarkedStateImpl
    implements LoadingResolveBookmarkedState {
  const _$LoadingResolveBookmarkedStateImpl();

  @override
  String toString() {
    return 'ResolveBookmarkedState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadingResolveBookmarkedStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loaded,
    required TResult Function() loading,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loaded,
    TResult? Function()? loading,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loaded,
    TResult Function()? loading,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadedResolveBookmarkedState value) loaded,
    required TResult Function(LoadingResolveBookmarkedState value) loading,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadedResolveBookmarkedState value)? loaded,
    TResult? Function(LoadingResolveBookmarkedState value)? loading,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadedResolveBookmarkedState value)? loaded,
    TResult Function(LoadingResolveBookmarkedState value)? loading,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class LoadingResolveBookmarkedState implements ResolveBookmarkedState {
  const factory LoadingResolveBookmarkedState() =
      _$LoadingResolveBookmarkedStateImpl;
}
